<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>death00</title>
    <link>https://death00.github.io/</link>
    <atom:link href="/atom.xml" rel="self" type="application/rss+xml"/>
    
    <description>all or nothing, now or never.</description>
    <pubDate>Thu, 25 Oct 2018 00:56:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>log4j日志不输出的问题</title>
      <link>https://death00.github.io/2018/10/24/log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <guid>https://death00.github.io/2018/10/24/log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Wed, 24 Oct 2018 09:03:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天服务器上报错，想先去看一下日志进行排查，结果发现日志很久都没有输出过了。从上午排查到下午，刚刚解决，因此记录一下，但现在也只是知其然，并不知其所以然，所以如果大家有什么想法请在下方评论。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天服务器上报错，想先去看一下日志进行排查，结果发现日志很久都没有输出过了。从上午排查到下午，刚刚解决，因此记录一下，但现在也只是知其然，并不知其所以然，所以如果大家有什么想法请在下方评论。<br><a id="more"></a></p><p>先说一下环境，服务器是linux，项目是运行在tomcat下的Spring项目，日志用的是log4j。</p><p>首先，从10月13号开始便没有新的日志文件了。假设日志名为log.txt（如果你设置了DailyRollingFileAppender，那么你当天的日志文件就是log.txt），先备份该文件到其他目录下，然后删除该文件，重新启动tomcat。这是为了确认你的log4j配置是否有问题，因为这是最容易出错的地方。很遗憾，我不是这里出的问题，因为项目重启后，日志文件又重新生成了，但很奇怪的是，<strong>日志文件是空的</strong>，其大小为0.</p><p>感觉自己碰上了很神奇的问题，因此我在自己的本地进行调试，启动项目后发现，正常的项目启动日志是有的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15:13:48:0253  INFO [RMI TCP Connection(3)-127.0.0.1] -Root WebApplicationContext: initialization completed in 18479 ms</span><br></pre></td></tr></table></figure></p><p>但我自己的一些日志输出是不显示的，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(MyDomain.class);</span><br><span class="line">log.info(<span class="string">"show info log"</span>);</span><br></pre></td></tr></table></figure></p><p><code>show info log</code>这句话就不打印，现在证明，我的日志配置没有问题，服务器也找到了我的日志文件，但应该是我自己的Logger是不对应正确的日志输出的，因为我的console(控制台)有显示。</p><p>接下来，我就是开始看源码了。先是<code>LoggerFactory.getLogger(Class&lt;?&gt; clazz)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Logger logger = getLogger(clazz.getName());</span><br><span class="line">    <span class="keyword">if</span> (DETECT_LOGGER_NAME_MISMATCH) &#123;</span><br><span class="line">        Class&lt;?&gt; autoComputedCallingClass = Util.getCallingClass();</span><br><span class="line">        <span class="keyword">if</span> (autoComputedCallingClass != <span class="keyword">null</span> &amp;&amp; nonMatchingClasses(clazz, autoComputedCallingClass)) &#123;</span><br><span class="line">            Util.report(String.format(<span class="string">"Detected logger name mismatch. Given name: \"%s\"; computed name: \"%s\"."</span>, logger.getName(),</span><br><span class="line">                            autoComputedCallingClass.getName()));</span><br><span class="line">            Util.report(<span class="string">"See "</span> + LOGGER_NAME_MISMATCH_URL + <span class="string">" for an explanation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好吧，没什么用，看不出我的<code>logger</code>变成了，继续看<code>getLogger(String name)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时我在<code>return iLoggerFactory.getLogger(name);</code>这行打了断点，我看到了这样的东西：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20181024172508.jpg?raw=true" alt="iLoggerFactory是logback中的实现"></p><p>为什么我的iLoggerFactory是用的logback中的实现？其实也是怪我自己大意，我其实依赖了一个基于Spring Boot的项目(虽然我只是用了里面的一些domain类，但因为设计不当，还没有把这些domain类单独提成一个_项目)，而Spring Boot中一般默认就依赖的logback。通过gradle查看项目的依赖树，也证实了我的这一猜想(./gradlew 子项目名称:dependencies):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|    +--- org.springframework.boot:spring-boot-starter-web:2.0.2.RELEASE</span><br><span class="line">|    |    +--- org.springframework.boot:spring-boot-starter:2.0.2.RELEASE</span><br><span class="line">|    |    |    +--- org.springframework.boot:spring-boot:2.0.2.RELEASE</span><br><span class="line">|    |    |    |    +--- org.springframework:spring-core:5.0.6.RELEASE (*)</span><br><span class="line">|    |    |    |    \--- org.springframework:spring-context:5.0.6.RELEASE (*)</span><br><span class="line">|    |    |    +--- org.springframework.boot:spring-boot-autoconfigure:2.0.2.RELEASE</span><br><span class="line">|    |    |    |    \--- org.springframework.boot:spring-boot:2.0.2.RELEASE (*)</span><br><span class="line">|    |    |    +--- org.springframework.boot:spring-boot-starter-logging:2.0.2.RELEASE</span><br><span class="line">|    |    |    |    +--- ch.qos.logback:logback-classic:1.2.3</span><br><span class="line">|    |    |    |    |    +--- ch.qos.logback:logback-core:1.2.3</span><br><span class="line">|    |    |    |    |    \--- org.slf4j:slf4j-api:1.7.25</span><br></pre></td></tr></table></figure></p><p>接下来就好办了，你排除掉<code>ch.qos.logback</code>的依赖就可以了，在你的<code>build.gradle</code>中增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    compile.exclude group: &apos;ch.qos.logback&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候你再重新调试一下看看：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20181024182956.jpg?raw=true" alt="iLoggerFactory是log4j中的实现"></p><p>完美，现在是log4j中的实现，得到了我想要的操作。当然了，既然我知道之前项目中的slf4j是logback实现了，那么我自然也可以换成logback的配置，但这就需要我将项目换成用Spring Boot启动，这个改动有点大，如果以后有必要的话，我再将这个exclude删除，换成Spring Boot的形式。</p><p>这次Spring Boot帮我们默认启用的是logback，那么有没有什么简单方法可以知道呢？如果你的项目出现了以下的日志输出，说明你的项目当前有不止一个SLF4J的实现组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/project.war/WEB-INF/lib/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/project.war/WEB-INF/lib/slf4j-log4j12-1.7.21.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]</span><br></pre></td></tr></table></figure></p><p>因为在<code>org.slf4j.LoggerFactory</code>的<code>bind</code>方法中有关于这方面的输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// skip check under android, see also</span></span><br><span class="line">        <span class="comment">// http://jira.qos.ch/browse/SLF4J-328</span></span><br><span class="line">        <span class="keyword">if</span> (!isAndroid()) &#123;</span><br><span class="line">            <span class="comment">// 查找你的当前项目有几个slf4j的实现</span></span><br><span class="line">            staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">            <span class="comment">// 如果多余一个就打印</span></span><br><span class="line">            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the next line does the binding</span></span><br><span class="line">        <span class="comment">// 这个是具体选了哪一个实现（重点关注）</span></span><br><span class="line">        StaticLoggerBinder.getSingleton();</span><br><span class="line">        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">        reportActualBinding(staticLoggerBinderPathSet);</span><br><span class="line">        fixSubstituteLoggers();</span><br><span class="line">        replayEvents();</span><br><span class="line">        <span class="comment">// release all resources in SUBST_FACTORY</span></span><br><span class="line">        SUBST_FACTORY.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">        String msg = ncde.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"Failed to load class \"org.slf4j.impl.StaticLoggerBinder\"."</span>);</span><br><span class="line">            Util.report(<span class="string">"Defaulting to no-operation (NOP) logger implementation"</span>);</span><br><span class="line">            Util.report(<span class="string">"See "</span> + NO_STATICLOGGERBINDER_URL + <span class="string">" for further details."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            failedBinding(ncde);</span><br><span class="line">            <span class="keyword">throw</span> ncde;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</span><br><span class="line">        String msg = nsme.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.contains(<span class="string">"org.slf4j.impl.StaticLoggerBinder.getSingleton()"</span>)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = FAILED_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"slf4j-api 1.6.x (or later) is incompatible with this binding."</span>);</span><br><span class="line">            Util.report(<span class="string">"Your binding is version 1.5.5 or earlier."</span>);</span><br><span class="line">            Util.report(<span class="string">"Upgrade your binding to version 1.6.x."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> nsme;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        failedBinding(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected initialization failure"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特别要注意的是<code>StaticLoggerBinder.getSingleton();</code>这行代码，<code>StaticLoggerBinder</code>在<strong>logback-classic</strong>和<strong>slf4j-log4j12</strong>这两个jar包各有一个，因此，Spring boot是自动选择<strong>logback-classic</strong>（虽然我在本地运行的时候还是默认进入的<strong>slf4j-log4j12</strong>，但是会提醒我<code>Source code does not match the bytecode</code>，因此我判断依旧进的是<strong>logback-classic</strong>），所以只要把logback给exclude掉，就解决了这个问题。</p><p>现在看问题，更加关注源代码，因为这可以让我们更加快速定位问题，并且也能据此大致猜出其解决方案。希望大家能一起看看源代码，如果你有什么发现，可以在下方留言，我将和你一起讨论。</p>]]></content:encoded>
      
      <comments>https://death00.github.io/2018/10/24/log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Netty 心跳相关(1)</title>
      <link>https://death00.github.io/2018/10/23/Netty-%E5%BF%83%E8%B7%B3%E7%9B%B8%E5%85%B3/</link>
      <guid>https://death00.github.io/2018/10/23/Netty-%E5%BF%83%E8%B7%B3%E7%9B%B8%E5%85%B3/</guid>
      <pubDate>Tue, 23 Oct 2018 07:49:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;无论是B/S还是C/S架构，如果你用的是长连接，那么心跳是必不可少的。Netty提供了对心跳机制的天然支持，今天结合例子特地学习了一下。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>无论是B/S还是C/S架构，如果你用的是长连接，那么心跳是必不可少的。Netty提供了对心跳机制的天然支持，今天结合例子特地学习了一下。<br><a id="more"></a></p><p>首先，我们来设想一下何时需要发送心跳。假设你做的是一款棋牌类小游戏，那么当玩家登陆游戏后肯定是先进入大厅，再选择一张合适的桌子正式开始游戏。此时玩家的客户端与服务器建立的这一次session（会话）应该是长久保持着，如果服务器端保存着大量的session，那么整个服务器就会越来越卡，最终整个服务都会挂掉。</p><p>为了预防这种情况，我们需要清理掉一些已经不用的或者理论上不会再用的session，比如：在手机上，如果我们在游戏中，突然接到一个电话或者退回桌面，这个时候我们的游戏客户端理论上就不会再主动向我们发送任何消息。这时候，心跳就派上用场了。</p><p><strong>心跳，是为了证明自己还活着。</strong>因此，这里的心跳，说白了就是客户端向服务器端发送一次请求，服务器端相应，这样客户端就知道了服务器端是alive(活着的)；服务器端向客户端发送一次心跳，客户端相应，这样服务器端就知道了客户端是alive。</p><p>知道了心跳的大致概念，那现在我们就需要知道Netty中是如何实现心跳，这就引出了两个类：<strong>IdleStateHandler</strong>、<strong>ChannelInboundHandlerAdapter</strong></p><h2 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h2><h3 id="大致作用"><a href="#大致作用" class="headerlink" title="大致作用"></a>大致作用</h3><blockquote><p>当连接的空闲时间（无论是读或者是写）太长时，都会触发IdleStateEvent事件。你可以写一个类继承ChannelInboundHandlerAdapter，重写userEventTriggered方法，来处理这类空闲事件。</p></blockquote><p>知道了其大致作用，那么接下来就看看我们到底该如何使用了。</p><p>IdleStateHandler有3个构造方法，主要针对这4个属性，分别是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> observeOutput;<span class="comment">// 是否考虑出站时较慢的情况。默认值是false（一般不考虑）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> readerIdleTimeNanos; <span class="comment">// 读事件空闲时间，0 代表禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> writerIdleTimeNanos;<span class="comment">// 写事件空闲时间，0 代表禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> allIdleTimeNanos; <span class="comment">//读或写空闲时间，0 代表禁用事件</span></span><br></pre></td></tr></table></figure></p><p>上面的三个时间，默认是秒，你也可以在构造的时候指定。</p><p>当你在pipeline中加入了该handler之后：</p><pre><code>pipeline.addLast(new IdleStateHandler(30, 90, 0)); // 这个代表只考虑读空闲30秒或写空闲90秒的情况</code></pre><p>则会先调用<code>handlerAdded</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123;</span><br><span class="line">        <span class="comment">// channelActive() event has been fired already, which means this.channelActive() will</span></span><br><span class="line">        <span class="comment">// not be invoked. We have to initialize here instead.</span></span><br><span class="line">        initialize(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// channelActive() event has not been fired yet.  this.channelActive() will be invoked</span></span><br><span class="line">        <span class="comment">// and initialization will occur there.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果channel正常，则调用<code>initialize</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> state; <span class="comment">// 0 - none, 1 - initialized, 2 - destroyed</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/143</span></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 避免重复添加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 如果处于destoryed状态，则不需要添加</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">    initOutputChanged(ctx);</span><br><span class="line"></span><br><span class="line">    lastReadTime = lastWriteTime = ticksInNanos();  <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="comment">// 添加相应的定时调度任务</span></span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// readerIdleTimeNanos时间后，执行ReaderIdleTimeoutTask里面的方法</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> ReaderIdleTimeoutTask(ctx),</span><br><span class="line">                readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> WriterIdleTimeoutTask(ctx),</span><br><span class="line">                writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">new</span> AllIdleTimeoutTask(ctx),</span><br><span class="line">                allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReaderIdleTimeoutTask、WriterIdleTimeoutTask、AllIdleTimeoutTask</code>均继承自类<code>AbstractIdleTask</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIdleTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    AbstractIdleTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ctx.channel().isOpen()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        run(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类需要实现的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以<code>ReaderIdleTimeoutTask</code>为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderIdleTimeoutTask</span> <span class="keyword">extends</span> <span class="title">AbstractIdleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReaderIdleTimeoutTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nextDelay = readerIdleTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (!reading) &#123; <span class="comment">// 如果不在读(channelRead时会被置为true，cahnnelReadComplete时会被置为false)</span></span><br><span class="line">            nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123; <span class="comment">// 说明读空闲时间达到或超过预设时间</span></span><br><span class="line">            <span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line">            readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="comment">// firstReaderIdleEvent，是否是第一次读空闲事件(该标志位会在下一次channelRead触发时改成true，所以应该理解在一次读取完成后，这个读空闲事件是不是第一次)</span></span><br><span class="line">            <span class="keyword">boolean</span> first = firstReaderIdleEvent;</span><br><span class="line">            firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 生成一个IdleStateEvent对象</span></span><br><span class="line">                IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">                <span class="comment">// 找到下一个ChannelInboundHandler类（或其子类）的handler，触发其userEventTrigger(可以参考AbstractChannelHandlerContext的fireUserEventTriggered方法)</span></span><br><span class="line">                channelIdle(ctx, event);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ctx.fireExceptionCaught(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 要么正在读，要么读空闲时间小于预设时间</span></span><br><span class="line">            <span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">            readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>schedule</code>方法可以理解为将定时调度事件放进一个队列当中（我是在<code>AbstractScheduledEventExecutor</code>里找到的<code>scheduledTaskQueue().add(task);</code>，但这里面的代码我还没看明白，有兴趣的你可以自己研究，研究完后如果有空可在下方评论）。<br><code>channelIdle(ctx, event)</code>方法时找到下一个ChannelInboundHandler类（或其子类）的handler，因此你写的继承自ChannelInboundHandler的handler，一定要添加在<code>IdleStateHandler</code>的后面，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">90</span>, <span class="number">0</span>));</span><br><span class="line">pipeline.addLast(heartbeatHandler);</span><br></pre></td></tr></table></figure></p><h2 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h2><p>它就很简单了，因为上面说了，channelIdle会调用ChannelInboundHandler的userEventTrigger，所以你只要自己写一个类继承ChannelInboundHandler，并重写它的userEventTrigger方法。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Sharable是因为我的每一个pipeline中用的都是同样的handler</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyHeartbeatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IHeartbeatFactory factory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyHeartbeatHandler</span><span class="params">(IHeartbeatFactory factory)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(factory);</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(evt <span class="keyword">instanceof</span> IdleStateEvent)) &#123;</span><br><span class="line">      <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123; <span class="comment">// 如果是读空闲，则关闭当前会话</span></span><br><span class="line">      ctx.close(); <span class="comment">// 此时会触发下一个ChannelOutboundHandler的close方法，你可以在自己写的handler中进行断线操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123; </span><br><span class="line">      <span class="comment">// 如果是写空闲，则向客户端发送心跳请求包，如果客户端不返回心跳相应包，则说明客户端断线，下一次就将触发读空闲事件。这也是为了向客户端证明服务器端alive</span></span><br><span class="line">      ctx.writeAndFlush(</span><br><span class="line">          <span class="keyword">new</span> BinaryWebSocketFrame(</span><br><span class="line">              Unpooled.copiedBuffer(factory.getHeartbeatRequest().toByteArray())</span><br><span class="line">          )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，以上就是关于用Netty实现心跳的简单介绍。其中带大家重点看了服务器端应该在什么情况下发起一次心跳请求，应该是长久没有收到消息时（可能是有业务含义的消息或者是一个心跳包）。如果大家有什么想法可以在下方评论。</p>]]></content:encoded>
      
      <comments>https://death00.github.io/2018/10/23/Netty-%E5%BF%83%E8%B7%B3%E7%9B%B8%E5%85%B3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>gitalk Error: Validation Failed</title>
      <link>https://death00.github.io/2018/09/30/gitalk%20Error%20Validation%20Failed/</link>
      <guid>https://death00.github.io/2018/09/30/gitalk%20Error%20Validation%20Failed/</guid>
      <pubDate>Sun, 30 Sep 2018 05:46:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;我现在博客的评论系统用的是gitalk，网上教程有很多，我参考的是这份&lt;a href=&quot;https://asdfv1929.github.io/2018/01/20/gitalk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;教程&lt;/a&gt;。&lt;/p&gt;
&lt;p
        
      
      </description>
      
      <content:encoded><![CDATA[<p>我现在博客的评论系统用的是gitalk，网上教程有很多，我参考的是这份<a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">教程</a>。</p><p>当我按照网上的说法搭好后，确实是可以利用issue进行评论了，但我在新发表文章时，竟然报错了：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20180930134404.jpg?raw=true" alt="Error: Validation Failed"></p><p>当时我心里一凉，难道和gitment一样，gitalk也凉了？后来上网查了一下，发现是github现在要求issue的label name不能超过50。<br>（奥，现在我才知道，原来gitalk应该是利用label进行筛选，取得当前评论所属的issus。但后来看了一下gitalk的源代码和github关于issue的api，issue的查找应该和你的number有关，而gitalk是当你没有number时就用id代替，看的有点晕。PS：本人在前端方面纯属小白）<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20180930140300.jpg?raw=true" alt="label name长度不能超过50"></p><p>好了，那就想想有什么办法可以保证名字的长度可以不超过50吧。没错，就是md5,加密过后都是32位长度，且唯一。当然了，这个也是在gitalk的<a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">issue</a>里查到的，接下来就来看看具体应该怎么做吧。</p><h2 id="找到js版的md5算法"><a href="#找到js版的md5算法" class="headerlink" title="找到js版的md5算法"></a>找到js版的md5算法</h2><p>首推的自然是别人已经造好的成熟的轮子，<strong><a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">JavaScript-MD5</a></strong>这个应该是可以的，亲测有效。</p><p>你只要在你的主题(比如我的就是next)下的<code>source\js\src</code>目录中创放入md5.js.min文件即可。</p><h2 id="修改gitalk-swig文件"><a href="#修改gitalk-swig文件" class="headerlink" title="修改gitalk.swig文件"></a>修改gitalk.swig文件</h2><p>原本你的文件内容应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>现在改成即可(修改了第4行和第12行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;/js/src/md5.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>然后重新发布就ok了，gitalk又可以正确创建issue了，你又可以继续评论了。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>因为gitalk关联issue是通过number，你没有number的时候，它会直接利用你的id，而id的这个生成条件又被你修改了，因此你之前评论是无法和你的文章关联上了。<br>如果对js稍微感兴趣的话，应该可以顺着这个思路往下能解决。博主有空也会试试，就当研究研究js，大家要是有成功的案例，可以在通过评论告知，毕竟这也是造福大家。<br>附上<a href="https://github.com/gitalk/gitalk/blob/master/dist/gitalk.js" target="_blank" rel="noopener">gitalk源码地址</a>。</p>]]></content:encoded>
      
      <comments>https://death00.github.io/2018/09/30/gitalk%20Error%20Validation%20Failed/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Centos6安装shadowsocks及配置</title>
      <link>https://death00.github.io/2018/09/30/Centos6%E5%AE%89%E8%A3%85shadowsocks%E5%8F%8A%E9%85%8D%E7%BD%AE/</link>
      <guid>https://death00.github.io/2018/09/30/Centos6%E5%AE%89%E8%A3%85shadowsocks%E5%8F%8A%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Sun, 30 Sep 2018 02:29:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;买下搬瓦工的服务器，很多人首先会希望配置多个端口方便使用，这时候就需要安装shadowsocks来解决。现在我来介绍一下Centos6系统下shadowsocks的安装及配置过程。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>买下搬瓦工的服务器，很多人首先会希望配置多个端口方便使用，这时候就需要安装shadowsocks来解决。现在我来介绍一下Centos6系统下shadowsocks的安装及配置过程。<br><a id="more"></a></p><p>这篇文章原是我在CSDN上发表的一篇博客，但在去年年底时莫名其妙被删除了，因此在这里，我把文章搬运过来，也是方便自己查看里面的一些命令。</p><p><a href="https://www.bwgyhw.com/" target="_blank" rel="noopener">这是一个搬瓦工的购买教程网站</a></p><h2 id="安装python、pip、shadowsocks"><a href="#安装python、pip、shadowsocks" class="headerlink" title="安装python、pip、shadowsocks"></a>安装python、pip、shadowsocks</h2><p>安装python：<br>    <code>yum install python-setuptools</code></p><p>安装wget<br>    <code>yum install wget</code></p><p>安装pip：（先下载再安装）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate</span><br><span class="line">tar -xzvf pip-1.3.1.tar.gz</span><br><span class="line">cd pip-1.3.1</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><p>安装shadowsocks<br>    <code>pip install shadowsocks</code></p><h2 id="配置shadowsocks"><a href="#配置shadowsocks" class="headerlink" title="配置shadowsocks"></a>配置shadowsocks</h2><p>首先创建配置文件/etc/shadowsocks.json<br>    <code>touch /etc/shadowsocks.json</code></p><p>创建并编辑shadowsocks.json<br>    <code>vi /etc/shadowsocks.json</code></p><p>现在要决定你是否需要开多端口，因为开出多个端口，每个端口的速度影响不大，但如果用同一个端口，速度会有所影响。 </p><p>shadowsocks.json内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;你的IP地址&quot;,</span><br><span class="line">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">&quot;port_password&quot;:&#123;</span><br><span class="line">&quot;端口号1&quot;:&quot;密码1&quot;,</span><br><span class="line">&quot;端口号2&quot;:&quot;密码2&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;timeout&quot;:600,</span><br><span class="line">&quot;method&quot;:&quot;rc4-md5&quot;,</span><br><span class="line">&quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应你本地的shadowsocks配置为：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/20171214113900502.png?raw=true" alt="本地shadowsocks配置"></p><p>这时可以在Centos上运行shadowsocks服务：<br>    <code>ssserver -c /etc/shadowsocks.json -d start</code></p><p>此时理论上你就可以科学上网了。</p><p>停止shadowsocks服务命令：<br>    <code>ssserver -c /etc/shadowsocks.json -d stop</code></p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>当你设置好配置文件并且启动之后，发现本地并不能上外网，其实可以通过shadowsocks的更新PAC功能查看是否可以连接外网：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/20171214114951081.png?raw=true" alt="更新PAC功能"></p><p>如果更新失败，则代表无法连接外网，这时候请看一下你的服务器上设置的端口是否开启：<br>    <code>netstat -ntlp</code></p><p>我开启了443、7788、7789、7790四个端口，如果你发现此处没有你的端口号，代表端口未打开<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/20171214115347347.png?raw=true" alt="检查端口是否打开"></p><p>此时你需要先关闭shadowsocks，使用关闭命令，然后打开你所需要的端口。</p><p>利用iptables打开端口命令:<br>    <code>/sbin/iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT</code></p><p>保存你刚刚添加的规则:<br>    <code>/etc/rc.d/init.d/iptables save</code></p><p>查看打开的端口：<br>    <code>/etc/init.d/iptables status</code></p><p>现在这里会显示出你刚刚打开的端口。</p><p>现在开启你服务器上的shadowsocks，再用查看端口命令，应该就显示出你的端口已经打开了。</p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p>shadowsocks相关下载包<br><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">安卓版本官方下载</a><br><a href="https://github.com/death00/gitment-comments/blob/master/resources/shadowsocks-win-2.3.zip" target="_blank" rel="noopener">电脑版Windows 7及之前的版本</a><br><a href="https://github.com/death00/gitment-comments/blob/master/resources/shadowsocks-win-dotnet4.0-2.3.zip" target="_blank" rel="noopener">电脑版Windows 8及之后的版本</a><br><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help" target="_blank" rel="noopener">iOS教程</a></p>]]></content:encoded>
      
      <comments>https://death00.github.io/2018/09/30/Centos6%E5%AE%89%E8%A3%85shadowsocks%E5%8F%8A%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>初章</title>
      <link>https://death00.github.io/2018/09/29/%E5%88%9D%E7%AB%A0/</link>
      <guid>https://death00.github.io/2018/09/29/%E5%88%9D%E7%AB%A0/</guid>
      <pubDate>Sat, 29 Sep 2018 08:10:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;第一次使用hexo写博客，希望能有一个不错的开始。&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>第一次使用hexo写博客，希望能有一个不错的开始。</p>]]></content:encoded>
      
      <comments>https://death00.github.io/2018/09/29/%E5%88%9D%E7%AB%A0/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
